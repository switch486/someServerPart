<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>IT Survival</title>

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="resources/css/reveal.css">
		<link rel="stylesheet" href="resources/css/theme/beige.css" id="theme">
		<link rel="stylesheet" href="resources/css/custom.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="resources/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'resources/css/print/pdf.css' : 'resources/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>IT Survival</h1>
					<h3>by Capgemini</h3>
					<aside class="notes">
						Press: 's' for presenter window<p>
						'ESC' for a global overview	
					</aside>
				</section>
				
				<!-- Capgemini logo! -->
				
				<section>
					<ul>
						<li><a href="#/GIT">GIT</a></li>
						<li><a href="#/Spring">Spring Framework</a></li>
						<li><a href="#/Maven">Maven</a></li>
						<li><a href="#/SpringBoot">Spring Boot</a></li>
						<li><a href="#/Arch">Architektura wielowarstwowa</a></li>
						<li><a href="#/REST">RESTful Services + Controller Advice</a></li>
						<li><a href="#/zadania1">** Zadania 1 ** ########</a></li>
						<li><a href="#/RelationalDBs">Relacyjne bazy danych a świat obiektowy + ORM</a></li>
						<li><a href="#/Mapstruct">Mapstruct ########</a></li>
						<li><a href="#/SpringData">Spring Data ########</a></li>
						<li><a href="#/Repository">Repository ########</a></li>
						<li><a href="#/zadania2">** Zadania 2 ** ########</a></li>
						<li><a href="#/Transactions">Transakcje</a></li>
						<li><a href="#/Tests">Testy</a></li>
						<li><a href="#/zadania3">** Zadania 3 ** ########</a></li>		
					</ul>
				</section>
				
				<!-- ------ -->
				<!-- ------ -->
				<!--  GIT   -->
				<!-- ------ -->
				<!-- ------ -->
				<section>
					<!-- Start -->
					<section id="GIT" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>GIT</h1>
					</section>
					
					<section>
						<h2>Git</h2>
						<ul>
							<li>Rozproszony system kontroli wersji</li>
							<li>Repozytorium gita to dowolny katalog w którym znajduje się podkatalog o nazwie .git</li>
							<li>Repozytorium po stronie serwera niczym nie różni się od repozytorium klienta</li>
							<li>Umożliwia pracę grupie osób na tych samych plikach w tym samym czasie</li>
							<li>Opublikowany na licencji GNU GPL</li>
							<li>Możliwość pracy off-line</li>
						</ul>
					</section>
					
					<section>
						<h2>git clone</h2>
						<ul>
							<li>Kopiuje istniejące repozytorium</li>
							<li>Lokalna kopia jest pełnowartościowym repozytorium</li>
							<ul>
								<li>posiada własną historię plików</li>
								<li>zarządza własnymi plikami</li>
								<li>jest zupełnie odizolowana od oryginalnego repozytorium</li>
								<li>umożliwia pracę offline</li>
							</ul>
						</ul>
					</section>
					
					<section>
						<h2>git config</h2>
						<ul>
							<li>Konfiguruje pojedyncze repozytorium lub ustawienia globalne</li>
							<li>Konfiguruje preferencje użytownika</li>
						</ul>
							
							<pre><code class="Bash" data-trim contenteditable>
git config user.name NAME
git config --global user.name NAME
git config --global user.email EMAIL
git config --global credential.helper store
</code></pre>
					</section>
					
					<section>
						<h2>git add</h2>
						<ul>
							<li>Dodaje zmieniony w katalogu roboczym plik do obszaru tymczasowego</li>
							<li>Powiadamia git’a, że ma załączyć zmiany danego pliku przy następnym commit’cie</li>
							<li>Nie wpływa znacząco na repozytorium</li>
							<pre><code class="Bash" data-trim contenteditable>
git add FILE
git add DIRECTORY
git add .
</code></pre>
							
						</ul>
					</section>
										
					<section>
						<h2>git commit</h2>
						<ul>
							<li>Dodaje wcześniej wybrane pliki do historii repozytorium (lokalnego)</li>
							<li>Brak interakcji w centralnym repozytorium (offline)</li>
							<li>Nie wpływa znacząco na repozytorium</li>
							<pre><code class="Bash" data-trim contenteditable>
git commit -m "MESSAGE"
</code></pre>
							<li>git add i git commit to dwa fundamentalne polecenia przepływu pracy</li>
						</ul>
					</section>
										
					<section>
						<h2>git push</h2>
						<ul>
							<li>Sposób wysłania lokalnych zmian i historii do zdalnego repozytorium</li>
							<li>W przypadku konfliktu zmiany nie zostaną „wypchnięte”</li>
							<li>Udostępnienie/upublicznienie zmian innym</li>
						</ul>
							<pre><code class="Bash" data-trim contenteditable>
git push REMOTE BRANCH
</code></pre>
					</section>
										
					<section>
						<h2>git fetch</h2>
						<ul>
							<li>Import gałęzi (branch) ze zdalnego repozytorium do lokalnego</li>
							<li>Pobrane zmiany nie modyfikują katalogu roboczego</li>
							<li>Możliwość przejrzenia zmian przed ostatecznym merge’m</li>
						</ul>
							<pre><code class="Bash" data-trim contenteditable>
git fetch REMOTE
</code></pre>
					</section>
							
					<section>
						<h2>git pull</h2>
						<ul>
							<li>Działa tak samo jak fetch z tą różnicą, że automatycznie wykonywany jest merge</li>
							<li>Zmiany ze zdalnego repozytorium od razu umieszczane są w lokalnym repozytorium</li>
						</ul>
							<pre><code class="Bash" data-trim contenteditable>
git pull REMOTE
</code></pre>
					</section>
							
					<section>
						<h2>git branch</h2>
						<ul>
							<li>Reprezentuje niezależne zmiany katalogu roboczego</li>
							<li>Komenda pozwala tworzyć, dodawać, zmieniać nazwy i usuwać gałęzie</li>
							<li>Zmiana gałęzi powoduje podmianę plików w bieżącym katalogu roboczym</li>
						</ul>
							<pre><code class="Bash" data-trim contenteditable>
git branch
git branch -r
git branch BRANCH
git branch -d BRANCH
</code></pre>
					</section>
							
					<section>
						<h2>git checkout (branch)</h2>
						<ul>
							<li>Umożliwia nawigację między gałęziami</li>
							<li>Podmienia pliki w bieżącym katalogu</li>
							<li>Zmienia kontekst – nowe commit’y będą przypisane do aktualnej gałęzi</li>
						</ul>
							<pre><code class="Bash" data-trim contenteditable>
git checkout EXISTING_BRANCH
git checkout -b NEW_BRANCH
</code></pre>
					</section>
					
					
					
					<section>
						<h2>Pozostałe komendy</h2>
						
						<ul>
							<li>git init</li>
							<li>git merge</li>
							<li>git status</li>
							<li>git log</li>
							<li>git revert</li>
							<li>git reset</li>
							<li>git stash</li>
						</ul>
						
					</section>
					
				</section>
				
				<!-- ------ -->
				<!-- ------ -->
				<!-- Spring -->
				<!-- ------ -->
				<!-- ------ -->
				<section>
					<!-- Start -->
					<section id="Spring" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Spring</h1>
					</section>
					
					<section>
					<h2>Spring Framework</h2>
					<ul>
						<li>Powstał w 2003 roku</li>						
						<li>Szkielet tworzenia aplikacji dla języka Java</li>
						<li>Alternatywa dla programowania w EJB</li>
						<li>Oferuje dużą swobodę wytwarzania oprogramowania</li>
						<li>Bardzo dobra dokumentacja</li>
						<li>Gotowa implementacja wielu zagadnień</li>
						<li>Ogromne wsparcie dla Java EE</li>
						<li>Propaguje poprawny styl programowania</li>
						<li>Jest dostępny na zasadach open source</li>
					</ul>
				</section>	
				
				<section>
					<h3>Spring Framework - moduły</h3>
					<ul>
						<li>Składa się z kilku niezależnych od siebie modułów</li>
						<li>Moduły można ze sobą łączyć w celu uzyskania większej funkcjonalności</li>
					</ul>
					<img src="resources/img/spring_modules.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
					<h3>Spring Framework – podstawowy kontener</h3>
					<ul>
						<li>Core</li>
							<ul> <li>podstawowa część frameworka, zawiera IoC i wstrzykiwanie zależności</li> </ul>
						<li>Beans</li>
							<ul> 	
								<li>eliminuje potrzebę programowego tworzenia singletonów</li>
								<li>oddziela zależność pomiędzy konfiguracją, specyfikacją a logiką programu</li> 
							</ul>
					</ul>
				</section>	

				<section>
					<h3>Spring Framework – podstawowy kontener</h3>
					<ul>							
						<li>Context</li>
							<ul> 	
								<li>umożliwia dostęp do obiektów zarządzanych przez framework</li>
								<li>pozwala na wydzielenie konfiguracji do plików *.properties</li>
								<li>udostępnia interface ApplicationContext</li> 
							</ul>
						<li>EL - Spring Expression Language</li>
					</ul>
					<pre><code class="Java" data-trim contenteditable>
@Value("#{applicationProperties['jakas.zmienna.z.pliku.properties']}")
private String zmienna;
					</code></pre>
				</section>
				
				<section>
					<h3>Inversion of Control, Dependency Injection</h3>
					<ul>
						<li>Paradygmat programowania, wzorzec projektowy, wzorzec architektoniczny.
						<li>Zastosowanie 
							<ul>
								<li>w pojedynczych komponentach,
								<li>w architekturze całego systemu (Spring Framework)
							</ul>
						<li>W klasycznym podejściu obiekty są budowane statycznie, brak wpływu na ich postać.
						<li>Odwracamy kontrolę – budowaniem obiektów zajmuje się framework
					</ul>
				</section>
				
				<section>
				<h3>Słyszałem / wygooglowałem że Spring to głównie konfiguracje XMLowe</h3>
					<ul> 	
						<li>Tak było kiedyś, teraz większość podstawowych konstrukcji może bez problemu być konfigurować za pomocą adnotacji</li>
						<li>Konfiguracje poprzez XML cały czas działają</li>
					</ul>
					<p class="fragment">
					Ale adnotacje w tej prezentacji nie są Interfejsami tylko Springowymi, ale też należącymi do JPA i Hibernate.
					</p>
				</section>
				
				<section>
					<h3>Inversion of Control, Dependency Injection</h3>
					<b>Wstrzykiwanie zależności</b> – dla danego obiektu definiujemy, z jakich innych komponentów będzie korzystał, ale nie musimy się martwić o tworzenie instancji tych obiektów – zrobi to za nas framework, wykorzystywane w Springu.
					
										<pre><code class="Java" data-trim contenteditable>
@Service
public class CustomerServiceImpl {

	private final CustomerMapper customerMapper;
	private final CustomerDao customerDao;
	
	@Autowired
	public CustomerServiceImpl (CustomerMapper mapper, CustomerDao dao) {
		this.customerMapper = mapper;
		this.customerDao = dao;
	}
					</code></pre>
				</section>
				
				<section>
				<h3>Jak zacząć ze springiem?</h3>
				
				<ol> 	
					<li> Podłączyć jary sciągnięte z internetu
					<li> <p class="fragment">W internecie poszukać dependency do POMa i podłączyć     </p>
					<li> <p class="fragment">Sciągnąć kompletny STS (Spring Tool Suite)               </p>
					<li> <p class="fragment">start.spring.io                                          </p>
				</ol>
				</section>
				
				<section>
				<h3>Spring framework - podstawy</h3>
				<pre><code class="Java" data-trim contenteditable>
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
public class BooksServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(BooksServerApplication.class, args);
	}
}
					</code></pre>
				</section>
				
				<section>
				<h3>Spring framework - adnotacje</h3>
					<ul>
						<li><b>@Component</b> - podstawowa adnotacja, określa że klasa jest zarządzana przez Spring
						<li><b>@Service</b> - określa klasę zawierającą logikę biznesową
						<li><b>@Repository</b> - klasy DAO (Data Access Object), bezpośrednia komunikacja z DB
					</ul>
					
						<p class="fragment">Wszystkie działają i robią to samo</p>
							<p class="fragment">Wyjątkiem jest @Repository, która dodatkowo konwertuje wyjątki dostawców bazy danych</p>
						<p class="fragment">Adnotacje pozwalają oddzielić od siebie różne warstwy aplikacji</p>
						<p class="fragment">Ułatwiają czytanie i analizowanie kodu</p>
				</section>
				
				<section>
				<h3>Spring framework - adnotacje</h3>
					<ul>
						<li><b>@Controller</b> - przetwarza żądania HTTP
						<li><b>@Scope</b> - umożliwia zmianę domyślnego czasu życia bean’a
						<li><b>@PostConstruct</b> - umożliwia wywołanie części kodu zaraz po utworzeniu obiektu
						<li><b>@RequestMapping</b> - używana w kontrolerze, mapuje adres URL na metodę
					</ul>
				</section>
				
				<section>
				<h3>Adnotacje - przykład</h3>
				<pre><code class="Java" data-trim contenteditable>
@RequestMapping("/services")
@RestController
public class BooksRestService {

    private final BookService bookService;

    @Autowired
    public BooksRestService(BookService bookService) {
        this.bookService = bookService;
    }

    @RequestMapping(path = "/books", method = RequestMethod.GET)
    public List&lt;BookTo&gt; findBooks(BookSearchCriteria bookSearchCriteria) {
        return bookService.findBooks(bookSearchCriteria);
    }
}
					</code></pre>
				</section>
				
				</section>
	
				<!-- ----- -->
				<!-- ----- -->
				<!-- Maven -->
				<!-- ----- -->
				<!-- ----- -->
				<section>
					<!-- Start -->
					<section id="Maven" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Maven</h1>
					</section>
					
					<section>
				<h3>Maven</h3>
                    <ul>
                      <li>Cel - Automatyzacja i standaryzacja procesu budowania</li>
                      <li>Umożliwia opis procesu budowania oprogramowania</li>
                      <li>Pozwala na zdefiniowanie zależności oraz zarządzanie nimi</li>
                      <li>Podział na centralne repozytorium artefaktów - search.maven.org</li>
                      <li>oraz lokalnie dostępne repozytorium deweloperskie</li>
                    </ul>
				</section>
                <section>
                  <h3>Struktura projektu - convention over configuration</h3>
                  <img src="resources/img/mvn.PNG" style="background:none; border:none; box-shadow:none;">
                </section>
              
                <section>
                  <h3>Konfiguracja projektu - POM (Project Object Model)</h3>
                  <img src="resources/img/pom.png" style="background:none; border:none; box-shadow:none;">
                </section>
              
                <section>
                  <h3>Maven build lifecycle</h3>
                  <ul>
                      <li>Zadania wykonywane kaskadowo - wykonanie konkretnego kroku powoduje również wykonanie wszystkich poprzedzających</li>
                      <li>mvn compile</li>
                    <li>Deweloper najczęściej używa <b>mvn clean install</b></li>
                    <li>Poszczególne pluginy korzystają ze zdefiniownaych faz w celu wykonania własnej akcji, np. <b>mvn surefire:test</b></li>
                  </ul>
                  <img src="resources/img/mvn_build.png" style="background:none; border:none; box-shadow:none;">
                </section>
				
			    <section>
                  <h3>Zarządzanie zależnościami - dependency management</h3>
                  <ul>
                      <li>Każda biblioteka posiada unikalny identyfikator - groupId, artifactId, version</li>
                      <li>Plik pom.xml zawiera sekcję dependencyManagement z listą zależności</li>
                      <li>Zależności są aktualizowane w procesie budowania</li>
                      <li>Centralne repozytorium artefaktów - search.maven.org</li>
                      <li>Lokalne repozytorium - lokalizacja definiowana dla użytkownika</li>
                    </ul>
                  <img src="resources/img/mvn_dependencies.png" style="background:none; border:none; box-shadow:none;">
                </section>

				</section>
				
				
	
				<!-- ---------- -->
				<!-- ---------- -->
				<!-- SpringBoot -->
				<!-- ---------- -->
				<!-- ---------- -->
				<section>
					<!-- Start -->
					<section id="SpringBoot" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Spring Boot</h1>
					</section>
					
					<section>
				<h3>Dlaczego Spring Boot?</h3>                    
                  <img src="resources/img/spring_summary.PNG" style="background:none; border:none; box-shadow:none;" >
                  <h5>+ Konfiguracja = Aplikacja startowa</h5>
				</section>				
                <section>
				<h3>Spring Boot</h3>                    
                  <ul>
                      <li>Convention over configuration</li>                      
                      <li>Przy zerowej konfiguracji działająca aplikacja</li>
                      <li>Prekonfiguracja możliwa dzięki adnotacjom @Conditional...</li>
                      <li>Generator projektu - start.spring.io</li>
                  </ul>
				</section>				
								
				<section>
				<h3>Spring boot / Startery</h3>
                  <ul>
                      <li>Zestawy zależności udostępniające prekonfigurowane funkcje Springa</li>                      
                      <li>Np. dla aplikacji bazodanowej: <pre><code>spring-boot-starter-data-jpa</code></pre></li>
                      <li>Lista starterów -> <a href='https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters'>spring-boot-starters</a></li>                    
                      <li>Jak użyc? -> pom.xml</li>                      
    <pre><code class="Xml">    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;</code></pre>
                  </ul>
				</section>				
								
				<section>
				<h3>Deployment aplikacji Spring Boot</h3>
                  <ul>
                      <li>Embedded Server</li>                      
                    <ol><li>Przy użyciu np. startera <pre><code class="Xml">spring-boot-starter-web</code></pre>
                      jar wynikowy (mvn clean install) zawiera jary Tomcata</li>
                    <li>Start klasy aplikacji uruchamia wbudowanego Tomcata (możliwe jest również użycie Jetty)</li>
                    </ol>  
                      <li>Klasyczny serwer J2EE lub zewnętrzny Tomcat</li>
                      Zmiana pliku docelowego na war, niewielkie zmiany w pom.xml
                  </ul>
				</section>

				</section>	
				
				
				
				<!-- ---- -->
				<!-- ---- -->
				<!-- Arch -->
				<!-- ---- -->
				<!-- ---- -->
				<section>
					<!-- Start -->
					<section id="Arch" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Architektura wielowarstwowa</h1>
					</section>
					
					<section>
					<h3>Architektura wielowarstwowa</h3>
					Efekt zastosowania SRP (Single Responsibility Principle)
					<table>
						<thead>
							<tr>
								<th>Rola</th>
								<th>Nazwa Warstwy</th>
								<th>Odpowiedzialność</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Komunikacja FrontEnd</td>
								<td>REST Service</td>
								<td>tłumaczenie requestów</td>
							</tr>
							<tr>
								<td>Use Case</td>
								<td>Service</td>
								<td>logika biznesowa</td>
							</tr>
							<tr>
								<td>Baza danych</td>
								<td>Repository / DAO</td>
								<td>persystencja</td>
							</tr>
						</tbody>
					</table>
				</section>
				
				<section>
					<h3>Architektura wielowarstwowa</h3>
					Czym jest Repository:
					<p><i>A Repository represents all objects of a certain type as a conceptual set. It acts like a collection, except with more elaborate querying capability.</i>[DDD]</p>
				</section>

				</section>
				
				
				<!-- ---- -->
				<!-- ---- -->
				<!-- REST -->
				<!-- ---- -->
				<!-- ---- -->
				<section>
					<!-- Start -->
					<section id="REST" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>RESTful Services</h1>
					</section>
					
					<section>
					<h3>RESTful Services</h3>
					<p><b>REST</b> - REpresentation State Transfer. Roy Fielding 2000.</p>
					<p>REST to nie jest architektura, tylko pewien zespół ograniczeń, który jeśli jest zastosowany do architektury to nadaje konkretne role danym, komponentom, hyperlinkom, ...</p>
				</section>
				<section>
					<h3>RESTful Services</h3>
					Wymagania stawiane przez definicję REST:
					<ol>
						<li>system klient - server
						<li>system bezstanowy
						<li>system udostępniający cache*
						<li>system jednolicie dostępny*
						<li>system wielowarstwowy
					</ol>
					<p>RESTful - spełniający wszystkie punkty powyższych założeń.</p>
				</section>
				<section>
					W świecie aplikacji internetowych definicja przekłada się na następujących kilka elementów:
					<ul>
						<li>Dane przesyłane między klientem a serwerem są pewną reprezentacją bytów biznesowych: XML, JSON
						<li>Dane przemieszczają się do konkretnego adresata URI (Uniform Resource Identifier)
						<li>Dane dodatkowo posiadają pewien kwalifikator akcji, mający odpowiednik w świecie protokołu HTTP
					</ul>
					<table>
						<thead>
							<tr>
								<th>Akcja</th>
								<th>Metoda HTTP</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><b>C</b>REATE</td>
								<td>POST</td>
							</tr>
							<tr>
								<td><b>R</b>ETRIEVE</td>
								<td>GET</td>
							</tr>
							<tr>
								<td><b>U</b>PDATE</td>
								<td>PUT</td>
							</tr>
							<tr>
								<td><b>D</b>ELETE</td>
								<td>DELETE</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<h3>RESTful API</h3>					
				<pre><code class="Java" data-trim contenteditable>
@RequestMapping(path = "/cars", method = RequestMethod.GET)
public List&lt;CarTo&gt; findAllCars() { ... }

@RequestMapping(path = "/car", method = RequestMethod.POST)
public CarTo addCar(@RequestBody CarTo car) { ... }

@RequestMapping(path = "/car", method = RequestMethod.PUT)
public CarTo updateCar(@RequestBody CarTo car) { ... }

@RequestMapping(path = "/car/{id}", method = RequestMethod.DELETE)
public boolean deleteCar(@PathVariable("id") Long id) { ... }
					</code></pre>
					<ul>
						<li><a href="http://www.thomas-bayer.com/sqlrest/CUSTOMER/1">Przykład GET 1</a>
						<li><a href="http://jsonplaceholder.typicode.com/posts/1/comments">Przykład GET 2</a>
					</ul>
				</section>

				</section>
				
				<!-- ---- -->
				<!-- ---- -->
				<!-- Controler Advice -->
				<!-- ---- -->
				<!-- ---- -->
				<section>
					<!-- Start -->
					<section id="REST" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Controler Advice</h1>
					</section>
					
					<section>
					<h3>Controler Advice - obsługa wyjątków warstwy serwisowej</h3>
					
					<pre><code class="Java" data-trim contenteditable>
@RequestMapping(path = "/car", method = RequestMethod.PUT)
public CarTo updateCar(@RequestBody CarTo car) { 

	// co jeśli Spring nie dostanie jako argument JSONa poprawnie - 
	// ale biznesowo poprawnie - tłumaczącego się na CarTo?

}

					</code></pre>	
				</section>
				
				<section>
					<h3>@Valid</h3>
					
					<pre><code class="Java" data-trim contenteditable>
@RequestMapping(path = "/car", method = RequestMethod.PUT)
public CarTo updateCar(@RequestBody @Valid CarTo car) { 

	// Metoda nie zostanie wywołana jesli walidacje okreslone deklaratywnie w CarTo nie przechodzą

}
					</code></pre>	
				</section>
				
				<section>
					<h3>CarTo</h3>
					
					<pre><code class="Java" data-trim contenteditable>
public class LegoSetTo {

	private long id;

	@NotNull
	@Size(min = 5, max = 200)
	private String name;

	@NotNull
	private Status status;

	@NotNull
	private Condition condition;
}
					</code></pre>	
				</section>
				
								<section>
					<h3>Obsługa wyjątku</h3>
					
					<pre><code class="Java" data-trim contenteditable>
@RestControllerAdvice
public class CarControllerAdvice {

	@ExceptionHandler({ MethodArgumentNotValidException.class })
	@ResponseStatus(value = HttpStatus.BAD_REQUEST)
	public List&lt;ErrorMessageTo&gt; validationException(MethodArgumentNotValidException ex) {
		ErrorMessageTo message = new ErrorMessageTo();
		message.setMessage(ex.getLocalizedMessage());
		return Lists.newArrayList(message);
	}
}
					</code></pre>	
				</section>

				</section>
				
				
				<!-- ZADANIA 1.X -->
				<section>
					<!-- Start -->
					<section id="zadania1" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Zadania 1.X</h1>
						<h2> branch: </h2>
					</section>
					
					<section>
						<h3>1.0 *</h3>
						<!-- TODO -->
						<!-- * hello world springbootowy -->
					</section>
					
					<section>
						<h3>1.1 **</h3>
						<!-- TODO -->
						<!-- ** resty pod CRUD --> 
						<!-- repository bez niczego w srodku i na wykladzie dopisanie extends i ze smiga --> 
					</section>
					
					<section>
						<h3>POSTMAN</h3>
						
						<!-- TODO -->
						
						
					</section>
					
					<section>
						<h3>1.2 ***</h3>
						<!-- TODO -->
						<!-- ** resty pod CRUD z postmanem --> 
						<!-- repository bez niczego w srodku i na wykladzie dopisanie extends i ze smiga --> 
					</section>

				</section>
				
				
				<!-- ------------- -->
				<!-- ------------- -->
				<!-- RelationalDBs -->
				<!-- ------------- -->
				<!-- ------------- -->
				<section>
					<!-- Start -->
					<section id="RelationalDBs" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Relacyjne bazy danych a świat obiektowy</h1>
					</section>
					
					<section>
				<h4>Relacyjne bazy danych a świat obiektowy</h4>
					<ul>
						<li>Aplikacje tworzą, zarządzają i przechowują informacje strukturalne
						<li>Programiści wybierają języki obiektowe
						<li>Zapisywanie i pobieranie danych wymaga znajomości SQL	
					</ul>
					
					<img src="resources/img/objectVSsql.PNG" style="background:none; border:none; box-shadow:none;">
				</section>
				
				
				<section>
				<h3>Dostęp do danych za pomocą JDBC</h3>
					<ul>
						<li>Bardzo dobrze znane API
						<li>Wymaga dobrej znajomości SQL
						<li>Łącze do baz danych dla języka Java	
					</ul>
					
					<img src="resources/img/jdbc.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>JDBC - jak to działa</h3>
				
					<pre><code class="Java" data-trim>
@Service public class CustomerServiceImpl {

   private static final String FIND_ALL_LIBRARIES_IN_CITY_SQL =
      "SELECT l.id, l.name, l.address_id FROM Library l, Address a 
       WHERE l.address_id = a.id AND a.city = :city";
   
   @Autowired private NamedParameterJdbcOperations jdbcTemplate;
   @Autowired private LibraryRowMapper mapper;
   
   public List&lt;LibraryTO&gt; findAllLibrariesInCity (String cityName) {
      SqlParameterSource params = new MapSqlParameterSource("city", cityName);
      return jdbcTemplate.query(FIND_ALL_LIBRARIES_IN_CITY_SQL, params, mapper);
   }
					</code></pre>				
				
					<ul>
						<li>Konieczność definiowania zapytań SQL
						<li>Spring NamedParameterJdbcOperations do wykonywania instrukcji SQL
						<li>Spring RowMapper do mapowania wyniku zapytania na obiekt	
					</ul>
				</section>
				
				
				<section>
				<h3>JDBC - spring RowMapper</h3>
				Implementacja interfejsu RowMapper
					<pre><code class="Java" data-trim>
@Component
public class LibraryRowMapper implements RowMapper&lt;LibraryTO&gt; {

   @Override
   public LibraryTO mapRow(ResultSet rs, int rowNum) throws SQLException {
      LibraryTO library = new LibraryTO();
      library.setId(rs.getLong(1));
      library.setName(rs.getString(2));
      library.setAddress(mapAddressById(rs.getLong(3)));
      return library;
   }
   
   private AddressTO mapAddressById(Long addressId) {
      if (addressId != null && Long.compare(0, addressId) != 0)
        return new AddressTO(addressId));
      return null;
   }
					</code></pre>				
				</section>
				
				<section>
				<h3>JDBC - wady</h3>
					<ul>
						<li>Wymaga pisania dużej ilości dodatkowego kodu
						<li>Trudne mapowanie wyniku SQL na obiekty biznesowe
						<li>Kod związany z trwałością danych narażony na błędy programistów
						<li>Brak przenośności kodu, implementacja zależna od bazy danych
						<li>Implementacja bardzo trudna w utrzymaniu
						<li>Ewentualne błędy w zapytaniach SQL widoczne dopiero w trakcie działania programu
						<li>Kod nietestowalny
					</ul>
				</section>		

				</section>
				
				
				<!-- --- -->
				<!-- --- -->
				<!-- ORM -->
				<!-- --- -->
				<!-- --- -->
				<section>
					<!-- Start -->
					<section id="ORM" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Odwzorowanie obiektowo-relacyjne</h1>
					</section>
					
					<section>
				<h3>Odwzorowanie obiektowo-relacyjne</h3>
					<ul>
						<li>Przekształcenie obiektów w encje bazy danych i odwrotnie
 						<li>Przekształcenie połączeń między obiektami na relacje bazy danych
 						<li>Przekształcenie obiektowego języka zapytań na SQL
 						<li>Spójny sposób obsługi różnych baz danych - przenośność
 						<li>Zapewnienie trwałości obiektów
 						<li>Ochrona programisty przed czasochłonnym SQL-em
 						<li>Pozwala skupić się na implementacji logiki biznesowej
 						<li>Zapewnienie stałych technik optymalizacyjnych
 						<li>Oddzielenie warstwy dostępu do danych od biznesu
					</ul>
				</section>
				
				<section>
				<h4>Odwzorowanie obiektowo-relacyjne</h4>
				Niedopasowanie paradygmatów relacyjno-obiektowych	
					<table>
						<thead>
							<tr>
								<th>Podobieństwa</th>
								<th>Różnice</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Klasy i tabele</td>
								<td>Szczegółowość</td> 
							</tr>
							<tr>
								<td>Właściwości i kolumny</td>
								<td>Dziedziczenie (java)</td> 
							</tr>
							<tr>
								<td>Instancje i wiersze</td>
								<td>Kolekcje (java)</td> 
							</tr>
							<tr>
								<td></td>
								<td>Identyczność (==, equals vs PK)</td> 
							</tr>
							<tr>
								<td></td>
								<td>Nawigacja po grafie obiektów</td> 
							</tr>
						</tbody>
					</table>
					<p class="fragment">Podstawowym zadaniem ORM jest rozwiązanie wrodzonych niezgodności pomiędzy obiektami i bazami danych</p>
				</section>

				</section>
				
								
				
				<!-- HIBERNATE -->
				<section>
					<!-- Start -->
					<section id="HIBERNATE" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>HIBERNATE</h1>
					</section>
					
					<section>
				<h3>Hibernate</h3>
					<ul>
						<li>Gavin King rozpoczął prace nad biblioteką pod koniec 2001 roku
						<li>Zespół na bieżąco realizował prośby użytkowników
						<li>Zgodny ze standardem JPA**
						<ul>
							<li>Możliwość traktowania Hibernate jako dostawcy trwałości
							<li>Możliwość używania bibliotek JPA, takich jak np. Spring-Data-Jpa
						</ul>
						<li>Oddziela kod biznesowy od warstwy dostepu do danych
					</ul>
				</section>		
				
				<section>
				<h3>Hibernate a development</h3>
					<img src="resources/img/hibernate_development_tooling.jpg" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>Hibernate a JPA</h3>
				<ul>
					<li>JPA - Java Persistence API
					<li>Hibernate jest implementacją JPA
					<li>Tak długo jak w projekcie używa się Hibernate można z jego adnotacji korzystać zamiennie z adnotacjami JPA
					<li>Jeśli planujemy kiedyś zmienić ORM, to warto ograniczyć się do adnotacji JPA
				</section>
				</ul>
				
				<section>
				<h3>Encja a <b>POJO</b></h3>
				
									<pre><code class="Java" data-trim>
public class LibraryEntity {
	private String name;
	private String domain;

	public LibraryEntity () {
	}

	public String getName() { return name; }

	public void setName(String name) { this.name = name; }
	
	public String getDomain() { return domain; }

	public void setDomain(String domain) { this. domain = domain; }
}
					</code></pre>
				</section>
				
				<section>
				<h3><b>Encja</b> a POJO</h3>
				
									<pre><code class="Java" data-trim>
@Entity
public class LibraryEntity {

	@Id
	private Long id;
	
	@Column(name = "name", length = 30, nullable = false)
	private String name;
	
	@Column(name = "domain", length = 5, nullable = true)
	private String domain;
	
	public LibraryEntity () {
	}
	
	// getters and setters
}

					</code></pre>
				</section>
				
				<section>
				<h4>Adnotacje dla Encji</h4>
				
									<pre><code class="Java" data-trim>
@Entity
@Table(name = "LIBRARY", schema = "public")
@Access(AccessType.FIELD)
public class LibraryEntity {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Long id;
	
	@Column(name = "name", length = 30, nullable = false)
	private String name;
	
	@Lob
	@Column(nullable = false)
	private String description;
	
	private String city;
	
	@Access(AccessType.PROPERTY)
	public String getCity ()  { ... }
	
	public LibraryEntity ()  { }
	
}
					</code></pre>
				</section>
				
				<section>
				<h4>Adnotacje dla Encji</h4>
					<ul>
						<li><b>@Entity</b> - oznacza klasę, odzwierciedla tabelę BD
						<li><b>@Entity(name="…")</b> - nigdy nie używać
						<li><b>@Access</b> - decyduje gdzie umieszczać adnotacje
						<li><b>@Table</b> - zmienia domyślną nazwę tabeli BD
						<li><b>@Id</b> - oznacza atrybut jako klucz główny
						<li><b>@GeneratedValue</b> - auto generacja wartości PK
						<li><b>@Column</b> - pozwala ustawić wartości kolumny
						<li><b>@Lob</b> - typ dla dużych danych tekstowych
						<li><b>@Enumerated(EnumType.STRING)</b> - enumy
						<li><b>@Transient</b> - wyłączenie pola z persystencji
						<li><b>@MappedSuperclas</b> - zwykłe dziedziczenie
					</ul>
				</section>
				
				<section>
				<h4>Typy Embedded</h4>
					<pre><code class="Java" data-trim>
@Embeddable
public class PersonalData  {

 private String firstName;
 
 private String lastName;
 
 @Column (columnDefinition=" DATE", nullable = false)
 private Date birthDate;

 public PersonalData()  {
 }
 
 // getters & setters     
 
}
					</code></pre>
				</section>
				
				<section>
				<h4>Typy Embedded</h4>
					<pre><code class="Java" data-trim>
@Entity
public class AuthorEntity  {

  @Embedded
  @AttributeOverrides({
       @AttributeOverride(
           name = "firstName", 
           column = @Column(
              name = "FIRST_NAME", 
              nullable = false)),
       @AttributeOverride(
           name = "lastName",
           column = @Column(
       	      name = "LAST_NAME", 
       	      nullable = false))})
  vate PersonalData personalData;
  
  ...
}
					</code></pre>
				</section>
				
				<section>
				<h3>Generowanie kluczy głównych - Strategie</h3>
					<pre><code class="Java" data-trim>
					
   @Id
   @GeneratedValue(strategy = GenerationType.AUTO)
   private Long id;
					</code></pre>
					<pre><code class="Java" data-trim>
					
   @Id
   @SequenceGenerator(name = "bookGen", sequenceName = "BOOK_SEQ")
   @GeneratedValue(strategy = GenerationType.SEQUENCE, 
					generator = "bookGen")
   private Long id;
					</code></pre>
				</section>
				
				<section>
				<h3>Generowanie kluczy głównych - Strategie</h3>
					<pre><code class="Java" data-trim>
					
    @Id
    @TableGenerator(
         name="bookGen",
         table="ID_GEN", // opcjonalnie
         pkColumnName="GEN_KEY", // opcjonalnie
         valueColumnName="GEN_VALUE", // opcjonalnie
         pkColumnValue="BOOK_ID_GEN") // opcjonalnie
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "bookGen")
    private Long id;
					</code></pre>
				</section>
				
				<section>
				<h3>Cykl życia encji</h3>
					<ul>
						<li>Adnotacje jako metadane opisujące mapowanie pomiędzy obiektem a bazą
						<li>Cykle życia encji:
						<ul>
							<li><b>nowy</b> (new) - brak identyfikatora i powiązania z kontekstem persystencji
							<li><b>zarządzany</b> (managed) – encja posiada ID i jest powiązana z kontekstem persystencji
							<li><b>odłączony</b> (detached) – encja posiada ID ale nie jest powiązana z kontekstem persystencji
							<li><b>usunięty</b> (removed) – tak jak zarządzany, ale oznaczona jako „do usunięcia”
						</ul>
					</ul>
				</section>
				
				<section>
				<h3>Listenery</h3>
					<ul>
						<li><b>@PrePersist</b>
						<li><b>@PostPersist    </b>
						<li><b>@PreUpdate      </b>
						<li><b>@PostUpdate     </b>
						<li><b>@PostLoad       </b>
						<li><b>@PreRemove      </b>
						<li><b>@PostRemove     </b>
					</ul>
				</section>
				
				<section>
				<h3>Listenery wewnątrz encji</h3>
					<pre><code class="Java" data-trim>
@Entity
@Table(name = "CUSTOMER_CARD")
public class CustomerCardEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
	
    @Column(nullable = false)
    private String serialNumber;

    @PrePersist
    public void generateDefaultSerialNumber() {
        serialNumber = new SerialNumberGenerator().generate();
    }
}
					</code></pre>
				</section>
				
				<section>
				<h3>Listenery stand alone</h3>
					<pre><code class="Java" data-trim>
@Entity
@Table(name = "CUSTOMER_CARD")
@EntityListeners(CustomerCardListener.class)
public class CustomerCardEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
	
    @Column(nullable = false)
    private String serialNumber;

}
					</code></pre>
				</section>
				
				<section>
				<h3>Listenery stand alone</h3>
					<pre><code class="Java" data-trim>
public class CustomerCardListener  {

    @PrePersist
    public void generateDefaultSerialNumber
			(CustomerCardEntity customerCardEntity) {
        String serialNumber = new SerialNumberGenerator().generate();
        customerCardEntity.setSerialNumber(serialNumber);
    }
	
}
					</code></pre>
				</section>
				
				<section>
				<h4>Entity Manager</h4>
					<ul>
						<li>Podstawowy element całej warstwy persystencji
						<li>Zarządza transakcjami i encjami
					</ul>
				
				
									<pre><code class="Java" data-trim>
String unitName = "MyPersistenceUnit";

// utwórz
EntityManagerFactory emf = Persistence.createEntityManagerFactory(unitName);
EntityManager em = emf.createEntityManager();

// zrób co masz do zrobienia
zrobCos(em);

// zamknij
em.close();
emf.close();
					</code></pre>
				</section>
				
				<section>
				<h4>Entity Manager - dostęp do danych</h4>
					<ul>
						<li>Podstawowy element całej warstwy persystencji
						<li>Zarządza transakcjami i encjami
					</ul>
									<pre><code class="Java" data-trim>
// zapis
Product banan = new Product(1, "banan", "owoce");
em.persist(banan);

// odczyt
Product bananFromDB = em.find(Product.class, 1);

// usunięcie
Product bananFromDB = em.find(Product.class, 1);
em.remove(bananFromDB);

// zapytanie
Product product = em.createQuery(
"SELECT p FROM Product p WHERE p.category = :cat_param", Product.class)
	.setParameter("cat_param", "owoce")
	.getSingleResult();

					</code></pre>
				</section>
				
				<section>
				<h3>Relacje</h3>
					<ul>
						<li><b>@OneToOne</b> – encja A może mieć relację do dokładnie jednej encji B
						<li><b>@OneToMany</b> – encja A może mieć relację do kilku encji B
						<li><b>@ManyToOne</b> – wiele encji A może mieć relację do dokładnie jednej encji B
						<li><b>@ManyToMany</b> – wiele encji A może mieć relację do wielu encji B
						<ul><li>Tworzy tabelę asocjacyjną</ul>
					</ul>
				</section>	
				
				<section>
				<h3>Relacje</h3>
					<ul>
						<li>Wyróżniamy relacje:
						<ul>
							<li>jednokierunkowe
							<li> dwukierunkowe
						</ul>
					</ul>
				</section>
				
				<section>
				<h3>@OneToOne - jednokierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@OneToOne(
		cascade = CascadeType.ALL, // default: empty
		fetch = FetchType.LAZY, // default: EAGER
		optional = false) // default: true
	private Address address;
}
					</code></pre>
				<pre><code class="Java" data-trim>
@Entity
public class Address {
}

					</code></pre>
				</section>
								
				<section>
				<h3>@OneToOne - dwukierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@OneToOne
	@JoinColumn(name = "ADDRESS_FK")
	private Address address;
}

					</code></pre>
				<pre><code class="Java" data-trim>
@Entity
public class Address {

	@OneToOne(mappedBy = „address”)
	private User user;
}
					</code></pre>
					<ul>
						<li><b>mappedBy</b> określa właściciela relacji
						<li>użytkownik ma klucz obcy do adresu
						<li>bez mappedBy klucz obcy po obu stronach
					</ul>
				</section>
				
				<section>
				<h3>@OneToMany / @ManyToOne - jednokierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@OneToMany(
	cascade = CascadeType.ALL, // default: empty
	fetch = FetchType. EAGER) // default: LAZY
	@JoinColumn(name = "user_id")
	private Collection&lt;Address&gt; addresses;
}

					</code></pre>
				<pre><code class="Java" data-trim>
@Entity
public class Address {
}
					</code></pre>
					<ul>
						<li>bez <b>@JoinColumn</b> utworzona zostanie tabela asocjacyjna
					</ul>
				</section>
				
				
				
				<section>
				<h3>@OneToMany / @ManyToOne - dwukierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@OneToMany(mappedBy = "user")
	private Collection&lt;Address&gt; addresses;
}

					</code></pre>
				<pre><code class="Java" data-trim>
@Entity
public class Address {

	@ManyToOne
	@JoinColumn(name = "ADDRESS_FK", nullable = false)
	private User user;
}
					</code></pre>
					<ul>
						<li>mappedBy tak samo jak <b>@JoinColumn</b> usuwa tabelę asocjacyjną
					</ul>
				</section>
				
				<section>
				<h3>@ManyToMany - jednokierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class User {

	@ManyToMany(
		cascade = CascadeType.ALL, // default: empty
		fetch = FetchType. LAZY) // default: EAGER    
	@JoinTable(name = "USER_ADDRESS",
		joinColumns = {@JoinColumn(
			name = "USER_ID", 
			nullable = false, 
			updatable = false)},
		inverseJoinColumns = {@JoinColumn(
			name = "ADDRESS_ID", 
			nullable = false, 
			updatable = false)})
	private Collection&lt;Address&gt; addresses;
}
					</code></pre>
				</section>
				
				<section>
				<h3>@ManyToMany - dwukierunkowa</h3>
				<pre><code class="Java" data-trim>
@Entity
public class Address {

    @ManyToMany(mappedBy = "user")
    private Collection&lt;User&gt; users;
}
					</code></pre>

					<ul>
						<li>bez mappedBy dwie tabele asocjacyjne zostaną stworzone
					</ul>
				</section>
				
				<section>
				<h3>Kaskady</h3>
					<ul>
						<li>Entity Manager dokonuje zmian na danej encji, np. persist
						<li>Kaskady umożliwiają operację na encji połączonej relacją
						<ul>
							<li><b>PERSIST      </b>
							<li><b>MERGE        </b>
							<li><b>REMOVE       </b>
							<li><b>ALL          </b>
						</ul>
					</ul>				
				</section>
				
				<section>
				<h3>Kaskady</h3>
				<pre><code class="Java" data-trim>
@Entity
@Table(name = "BOOK")
public class BookEntity  {

    @OneToOne(cascade = CascadeType.ALL, mappedBy = "book")
    private BookSpoilerEntity bookSpoiler;
	
}
					</code></pre>			
				</section>
				
				<section>
				<h3>Dziedziczenie</h3>
					<ul>
						<li>Naturalna właściwość obiektów
						<li>Nie ma zastosowania w relacyjnych bazach danych
						<li>Rozwiązaniem Hibernate są trzy strategie:
						<ul>
							<li><b>SINGLE_TABLE        </b>
							<li><b>TABLE_PER_CLASS       </b>
							<li><b>JOINED          </b>
						</ul>
						<li>Możliwość wykonywania zapytań polimorficznych
					</ul>	
				</section>
				
				<section>
				<h3>Strategie: Single Table</h3>
					<ul>
						<li>Podobne obiekty przechowywane są w jednej tabeli
						<li>Rekordy rozróżniane są przez tzw. Dyskryminator
						<li>Wydajne wyszukiwanie – brak złączeń
						<li>Puste kolumny (różnice między obiektami)
						<li>Problem z warunkiem Not-Null. 
					</ul>	
				</section>
				
				<section>
				<h3>Strategie: Single Table</h3>
				<pre><code class="Java" data-trim>
@Entity
@Table(name = "AUTHOR")
@DiscriminatorColumn(name = "TYPE", length = 6, 
		discriminatorType = DiscriminatorType.STRING)
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public abstract class AuthorEntity  {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    protected Long id;
	
    @Column(nullable = true, length = 30)
    protected String nickName;

}
					</code></pre>			
				</section>
				
				<section>
				<h3>Strategie: Single Table</h3>
				<pre><code class="Java" data-trim>
@Entity
@DiscriminatorValue("WRITER")
public class WriterEntity extends AuthorEntity  {

    @Enumerated(EnumType.STRING)
    private LiteraryGenre literaryGenre;
	
}
					</code></pre>	
				</section>
				
				<section>
				<h3>Strategie: Single Table</h3>
				<pre><code class="Java" data-trim>
@Entity
@DiscriminatorValue("PROFES")
public class ProfessorEntity extends AuthorEntity  {

    @Column(nullable = true)
    private String university;

}
					</code></pre>	
				</section>
				
				<section>
					<h3>Strategie: Single Table</h3>
					<img src="resources/img/inheritance_single_table_db.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>Strategie: Table per class</h3>
					<ul>
						<li>Oddzielna tabela bazy danych na jedną encję
						<li>Brak porblemów z warunkami Not-Null
						<li>Redundancja wspólnych atrybótów
						<li>Niewydajne zapytania SQL przy zapytaniach polimorficznych 

					</ul>
				</section>
				
				<section>
				<h3>Strategie: Joined</h3>
					<ul>
						<li>Bazowe obiekty zapisane są w jednej tabeli
						<li>Różnice między obiektami zapisywane są w oddzielnych tabelach
						<li>Znormalizowana baza danych
						<li>Brak redundancji
						<li>Wymagane złączenie tabel przy zapytaniach polimorficznych
					</ul>
				</section>
				
				<section>
				<h3>Strategie: Joined</h3>
				<pre><code class="Java" data-trim>
@Entity
@Table(name = "BOOK_EXEMPLAR")
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class BookExemplarEntity  {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    protected Long id;
	
    @Column(nullable = false, length = 15, unique = true)
    protected String serialNumber;
}
					</code></pre>	
				<img src="resources/img/inheritance_joined_db_1.png" style="background:none; border:none; box-shadow:none;">
				</section>
				
				<section>
				<h3>Strategie: Joined</h3>
				<pre><code class="Java" data-trim>
@Entity
@Table(name = "PAPER_BOOK")
@PrimaryKeyJoinColumn(name = "book_ex_id", referencedColumnName = "id")
public class PaperBookExemplarEntity extends BookExemplarEntity  {

    private int pagesCount;
	
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PaperSize paperSize;
	
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private BookCover bookCover;
}
					</code></pre>	
				<img src="resources/img/inheritance_joined_db_2.png" style="background:none; border:none; box-shadow:none;">
				</section>		

				</section>
				
				
				<!-- Mapstruct -->
				<section>
					<!-- Start -->
					<section id="Mapstruct" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Mapstruct</h1>
					</section>
					
					<section>
						<h3>Po co mapowanie?</h3>
						<ul>
							<li>Encja-TransportObject
							<ul>
								<li>Izolacja warstwy danych od całej reszty
							</ul>
							<br>
							<li>TransportObject-TransportObject
							<ul>
								<li>Tłumaczenie danych na różne interfejsy
							</ul>
						</ul>
					</section>
					
					<section>
						<h3>Jak można mapować</h3>
						<ul>
							<li>ręcznie (unikać)
							<li>automatyczne
							<ul>
								<li>z wzkorzystaniem refleksji (Dozer, ...)
								<li>z wzkorzystaniem generowania bajtkodu (Orika, ...)
								<li>z wzkorzystaniem generowania kodu (Mapstruct, ...)
							</ul>
						</ul>
					</section>
					
					<section>
						<h3>Mapstruct - proste atrybuty różniące się nazwą</h3>
<pre><code class="Java" data-trim contenteditable>
    @Mappings({
        @Mapping(source = "orders", target = "orderItems"),
        @Mapping(source = "customerName", target = "name")
    })
    Customer toCustomer(CustomerDto customerDto);
</code></pre>
<a href="https://github.com/mapstruct/mapstruct-examples/blob/master/mapstruct-field-mapping/src/main/java/org/mapstruct/example/mapper/CustomerMapper.java"> LINK </a>
					</section>
					
										<section>
						<h3>Mapstruct - złożone obiekty</h3>
<pre><code class="Java" data-trim contenteditable>
    @Mappings({
        @Mapping(target = "fish.kind", source = "fish.type"),
        @Mapping(target = "fish.name", ignore = true),
        @Mapping(target = "ornament", source = "interior.ornament"),
        @Mapping(target = "material.materialType", source = "material"),
        @Mapping(target = "quality.report.organisation.name", source = "quality.report.organisationName")
    })
    FishTankDto map(FishTank source);
</code></pre>
<a href="https://github.com/mapstruct/mapstruct-examples/blob/master/mapstruct-nested-bean-mappings/src/main/java/org/mapstruct/example/mapper/FishTankMapper.java"> LINK </a>
					</section>
					
					<section>
						<h3>Mapstruct - trudniejsze mapowania</h3>
							<ul>
								<li>mapowanie z kolekcjami
								<li>mapowanie z zapętlonymi obiektami
								<li>mapowanie z zaokrągleniami wartości
								<li>mapowanie obiektów nie przestrzegających konwencji get-set
							</ul>
<a href="https://github.com/mapstruct/mapstruct-examples"> LINK </a>
					</section>
				</section>

				
				<!-- SpringData -->
				<section>
					<!-- Start -->
					<section id="SpringData" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Spring Data</h1>
					</section>
				<!-- TODO -->

				</section>
				
				<!-- Repository -->
				<section>
					<!-- Start -->
					<section id="Repository" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Repository</h1>
					</section>
				<!-- TODO -->

				</section>
				
				
				<!-- ZADANIA 2.X -->
				<section>
					<!-- Start -->
					<section id="zadania2" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Zadania 2.X</h1>
						<h2> branch: </h2>
					</section>
					
					<section>
						<h3>2.0 *</h3>
						<!-- TODO -->
						<!-- * JPA Query methods - konwencje -->
					</section>
					
					<section>
						<h3>2.1 *</h3>
						<!-- TODO -->
						<!-- @Query adnotacja --> 
					</section>
					
					<section>
						<h3>2.2 **</h3>
						<!-- TODO -->
						<!-- Query DSL --> 
					</section>

				</section>
				
				
				
				<!-- Transactions -->
				<section>
					<!-- Start -->
					<section id="Transactions" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Transakcje</h1>
					</section>
					
					<section>
				<h3>Transakcje</h3>
					<ul>
						<li>Zbiór operacji na bazie danych stanowiących jedną całość
 						<li>Zmieniają spójny stan bazy danych w inny spójny stan
 						<li>Cechy transakcji:
						<ul>
							<li>Atomowość (<b>A</b>tomicity)
							<li>Spójność (<b>C</b>onsistency)
							<li>Izolacja (<b>I</b>soation)
							<li>Trwałość (<b>D</b>urability)	
						</ul>
					</ul>
				</section>
				
				<section>
				<h4>Transakcje - Entity Manager</h4>
				
									<pre><code class="Java" data-trim>
// rozpoczyna transakcję
em.getTransaction().begin();

// wykonanie operacji
Product prodFromDb = em.find(Product.class, 1);
prodFromDb.setCategory("newCategory");

// zatwierdzenie transakcji
em.getTransaction().commit();

// ewentualne wycofanie transakcji
em.getTransaction().rollback();
					</code></pre>
				</section>
				
				<section>
				Transakcje Spring <b>@Transactional</b>
				
					<ul>
						<li>Najlepszy sposób budowania transakcyjnych aplikacji Spring 
 						<li>Brak powielonego kodu
						<li>Bardzo łatwa konfiguracja
						<li>Propagacja, izolacja, timeout, readOnly, rollbackFor itp.
						<li>Możliwość zdefiniowania na całej klasie i metodzie
					</ul>
				</section>	

				<section>
				<h4>@Transactional</h4>
									<pre><code class="Java" data-trim>
@Service
@Transactional(readOnly = true)
public class LibraryServiceImpl implements LibraryService {

	@Autowired
	private LibraryRepository libraryRepository;
	
	@Autowired
	private MapperFacade mapper;
	
	@Override
	public List&lt;LibraryTO&gt; findAllLibraries () {
		List&lt;LibraryEntity&gt; libraries = libraryRepository.findAll();
		return mapper.mapAsList(libraries, LibraryTO.class);
	}
}
					</code></pre>
				</section>	

				</section>
				
				
				<!-- Tests -->
				<section>
					<!-- Start -->
					<section id="Tests" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Testy</h1>
					</section>
					
					<section>
				<h3>Po co testy?</h3>
				
				</section>
				
				
						<!-- TODO -->
				<section>		
				
				<img src="resources/img/sc.jpg" style="background:none; border:none; box-shadow:none;">
				
				</section>
				
				<section>
				<h3>Jakie testy warto tworzyć</h3>
					<ol>
						<li>Jednostkowe
						<li>Integracyjne	
						<li>Komponentowe
						<li>E2E
						<li>Akceptacyjne
					</ol>
					<p>
					<small><a href="https://en.wikipedia.org/wiki/Software_testing">Wikipedia</a></small>
					</p>
				</section>
				
				<section>
				<h3>Jakie narzędzia wykorzystywać przy tworzeniu testów</h3>
					<ol>
						<li>Mockowanie zależności
						<li>Asercje
						<li>given-when-then
						<li>Continuous Integration
						<li>Argument Captors
						<li>...
					</ol>
				</section>
				
				<section>
				<h3>Test Jednostkowy z wykorzystaniem MockMVC</h3>
				<pre><code class="Java" data-trim>		
@EnableWebMvc
@ComponentScan("org.itsurvival.books.rest")
public static class BooksRestServiceTestConfiguration {

    @Bean
    public BookService bookService() {
        return Mockito.mock(BookService.class);
    }
}

private MockMvc mockMvc;

@Autowired
private WebApplicationContext webApplicationContext;

@Autowired
private BookService bookService;

@Captor
private ArgumentCaptor&lt;BookSearchCriteria&gt; bookSearchCriteriaCaptor;

@Captor
private ArgumentCaptor&lt;BookTo&gt; bookCaptor;
				
@Test
public void shouldAddNewBook() throws Exception {

    // given
    byte[] content = readFileToBytes(
		"classpath:org/itsurvival/books/rest/newBook.json");

    when(bookService.addBook(any(BookTo.class)))
		.thenAnswer(args -> args.getArguments()[0]);

    // when
    mockMvc.perform(post("/services/book")
			.content(content)
			.contentType(MediaType.APPLICATION_JSON))
            // then
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.title", is("Test title")));


    verify(bookService).addBook(bookCaptor.capture());
    BookTo book = bookCaptor.getValue();
    assertThat(book.getTitle()).isEqualTo("Test title");
    assertThat(book.getAuthor()).isEqualTo("Test author");
    assertThat(book.getYear()).isEqualTo(2008);
    assertThat(book.getGenre()).isEqualTo(Genre.IT);
    assertThat(book.getVersion()).isEqualTo(0L);
    assertThat(book.getId()).isNull();
}
				</code></pre>
				</section>

				</section>
				
				
				<!-- * junity zwykle-->
				<!-- * junity mockmvc - testowanie restow -->
				<!-- ** mockowanie - argument captors -->
				
				<!-- ZADANIA 3.X -->
				<section>
					<!-- Start -->
					<section id="zadania3" data-transition="slide" data-background="orange" data-background-transition="zoom">
						<h1>Zadania 3.X</h1>
						<h2> branch: </h2>
					</section>
					
					<section>
						<h3>3.0 *</h3>
						<!-- TODO -->
						<!-- * junity zwykle -->
					</section>
					
					<section>
						<h3>3.1 *</h3>
						<!-- TODO -->
						<!-- * junity mockmvc - testowanie restow --> 
					</section>
					
					<section>
						<h3>3.2 **</h3>
						<!-- TODO -->
						<!-- ** mockowanie - argument captors --> 
					</section>

				</section>
				
				
			
				<section id="ex" style="text-align: left;" data-transition="slide" data-background="lime" data-background-transition="zoom">
					<h1>?</h1>
					<h4>Questions</h4>
				</section>

			</div>

		</div>

		<script src="resources/lib/js/head.min.js"></script>
		<script src="resources/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
			slideNumber: true,
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'resources/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'resources/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'resources/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'resources/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'resources/plugin/zoom-js/zoom.js', async: true },
					{ src: 'resources/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
